# zeroremainder

For a sampling tool (sample 1 in n events) I was looking for a way to determine if a given number **x** (generated by a random number generator) is divisable through a constant value **d** (the sampling rate) without remainder. For this special use case the effective value of the remainder is not relevant. The relevant thing for this use case is to evenly select values out of a large number range (in my case a random generated unsigned 32 bit integer), based on the given sampling rate (**d**). Therefore the function should return true for 1 in **d** cases and false otherwise.

The resulting operation should be fast, because it is performed many times per second, actually for every network package, received on the system performing the operation.

The goal of this tool is to test one of the posible solution, which is based on the integer overflow wrap around (especially the free modulo operation comming with the wrap around) and a multiplication with the reciprocal value.

## The implemented solution

The main idea is to replace the modulo operation with a multiplication by the reciprocal value of **d** and take advantage of the *free* integer wrap around modulo operation, occuring if the multiplication overflows umaxint32.

The to take advantage of the free integer wrap around modulo operation, the reciprocal of **d** is calculated as follows:

`reciprocal(d) = maxuint32 / d + 1`

The whole function is:

`x * reciprocal(d) % 256 < reciprocal(d)`

The modulo 256 (`% 256`) is performed by the processor for free, if the previous multiplication overflows umaxint32.

Due to the fact that all operations are performed by whole numbers, the reciprocal of **d** as defined above is not totaly accurate. This is resulting in a slight shifting of the calculated results. The purpose of the zeroremainder app is to show how this inaccuracy is influencing the overall result of this solution.

## The obvious solution

The obvious solution is to use the modulo operation.

`x % d == 0`

In my use case there are two problems with this solution:

1. The modulo operation is, like the division operation for integer values, quite slow
2. In my special situation there is no modulo operation available